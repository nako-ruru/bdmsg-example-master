// Copyright 2016 someonegg. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package golog

import (
	"fmt"
	"os"
	"reflect"
	"sync"
	"time"
)

// Supported log level.
const (
	LevelDebug = iota
	LevelInfo
	LevelWarn
	LevelError
	LevelPanic
	LevelFatal
)

// Fields is map type of field-key to field-value.
type Fields map[string]interface{}

// Log represents a single structured log.
type Log struct {
	Level   int
	Time    time.Time
	Message string
	Fields  Fields // not nil
}

// Handler is used to process logs, outputting them to stdio, file or
// remote services.
//
// Implementations must not retain log, but can modify it temporarily.
//
// Multiple goroutines may invoke methods on a Handler simultaneously.
type Handler interface {
	ProcessLog(l *Log)
}

// The HandlerFunc type is an adapter to allow the use of ordinary functions
// as log handlers. If f is a function with the appropriate signature,
// HandlerFunc(f) is a Handler object that calls f.
type HandlerFunc func(l *Log) error

func (f HandlerFunc) ProcessLog(l *Log) {
	f(l)
}

// Logger is the logger interface.
type Logger interface {
	// Create a sub logger from this logger.
	SubLogger() Logger

	// Level property. It controls whether a log will be
	// passed to the handler, the rule is:
	//   [log.level >= logger.level]
	//
	// When not setted, use the inherited value.
	//
	Level() int
	SetLevel(level int)
	UnsetLevel()

	// Handler property. The log will be passed to it.
	//
	// When nil,logs will be discarded.
	// When not setted, use the inherited value.
	//
	Handler() Handler
	SetHandler(handler Handler)
	UnsetHandler()

	// Predefs property. All logs generated by this logger will include them.
	//
	// Called when log, returns (inherited + its own) "predefs".
	//   [pick its own when repeated in merging]
	Predefs() Fields
	AddPredef(key string, val interface{})
	DelPredef(key string)

	// Log operation.
	//
	Debug(message string, kvfields ...interface{})
	Info(message string, kvfields ...interface{})
	Warn(message string, kvfields ...interface{})
	Error(message string, kvfields ...interface{})
	// Log followed by a call to panic(message).
	Panic(message string, kvfields ...interface{})
	// Log followed by a call to os.Exit(1).
	Fatal(message string, kvfields ...interface{})
}

// SubLogger followed by AddPredef... .
func SubLoggerWithFields(parent Logger, kvfields ...interface{}) Logger {
	subLogger := parent.SubLogger()
	if (len(kvfields) % 2) != 0 {
		panic("golog : invalid kvfields")
	}
	for i := 0; i < len(kvfields); i += 2 {
		k, ok := kvfields[i].(string)
		if !ok {
			panic("golog : invalid kvfields")
		}
		v := kvfields[i+1]
		subLogger.AddPredef(k, v)
	}
	return subLogger
}

// SubLogger followed by SetLevel .
func SubLoggerWithLevel(parent Logger, level int) Logger {
	subLogger := parent.SubLogger()
	subLogger.SetLevel(level)
	return subLogger
}

// SubLogger followed by SetHandler .
func SubLoggerWithHandler(parent Logger, handler Handler) Logger {
	subLogger := parent.SubLogger()
	subLogger.SetHandler(handler)
	return subLogger
}

type logger struct {
	parent Logger

	locker sync.RWMutex

	level       int
	levelSetted bool

	handler       Handler
	handlerSetted bool

	predefs Fields
	// cache
	predefsInh Fields // inherited
	predefsCur Fields // current
	predefsFin Fields // final
}

// The root logger, its level is debug, its
// handler is NewHandler(os.Stderr).
var RootLogger Logger = &logger{
	level:         LevelDebug,
	levelSetted:   true,
	handler:       NewHandler(os.Stderr),
	handlerSetted: true,
}

func (l *logger) lazyInit() {
	if l.predefs == nil {
		l.predefs = make(Fields)
	}
}

func (l *logger) isRoot() bool {
	return l.parent == nil
}

func (l *logger) SubLogger() Logger {
	return &logger{
		parent:        l,
		levelSetted:   false,
		handlerSetted: false,
	}
}

func (l *logger) Level() int {
	l.locker.RLock()
	defer l.locker.RUnlock()
	if l.isRoot() || l.levelSetted {
		return l.level
	}
	return l.parent.Level()
}

func (l *logger) SetLevel(level int) {
	l.locker.Lock()
	defer l.locker.Unlock()
	l.level = level
	l.levelSetted = true
}

func (l *logger) UnsetLevel() {
	l.locker.Lock()
	defer l.locker.Unlock()
	if l.isRoot() {
		return
	}
	l.levelSetted = false
}

func (l *logger) Handler() Handler {
	l.locker.RLock()
	defer l.locker.RUnlock()
	if l.isRoot() || l.handlerSetted {
		return l.handler
	}
	return l.parent.Handler()
}

func (l *logger) SetHandler(handler Handler) {
	l.locker.Lock()
	defer l.locker.Unlock()
	l.handler = handler
	l.handlerSetted = true
}

func (l *logger) UnsetHandler() {
	l.locker.Lock()
	defer l.locker.Unlock()
	if l.isRoot() {
		return
	}
	l.handlerSetted = false
}

func (l *logger) Predefs() Fields {
	var predefsInh Fields
	if !l.isRoot() {
		predefsInh = l.parent.Predefs()
	}

	// fast way
	if cache, ok := l.predefsFromCache(predefsInh); ok {
		return cache
	}

	l.locker.Lock()
	defer l.locker.Unlock()

	// merge
	predefsCur := l.predefs
	predefsFin := make(Fields)
	for k, v := range predefsInh {
		predefsFin[k] = v
	}
	for k, v := range predefsCur {
		predefsFin[k] = v
	}
	if len(predefsFin) == 0 {
		predefsFin = nil
	}

	// cache
	l.predefsInh = predefsInh
	l.predefsCur = predefsCur
	l.predefsFin = predefsFin
	return predefsFin
}

func (l *logger) predefsFromCache(predefsInh Fields) (Fields, bool) {
	l.locker.RLock()
	defer l.locker.RUnlock()
	predefsCur := l.predefs
	if reflect.ValueOf(predefsInh).Pointer() == reflect.ValueOf(l.predefsInh).Pointer() &&
		reflect.ValueOf(predefsCur).Pointer() == reflect.ValueOf(l.predefsCur).Pointer() {
		return l.predefsFin, true
	}
	return nil, false
}

func (l *logger) AddPredef(key string, val interface{}) {
	l.locker.Lock()
	defer l.locker.Unlock()
	l.lazyInit()
	l.predefs[key] = specialV(val)
	l.clearPredefsCache()
}

func (l *logger) DelPredef(key string) {
	l.locker.Lock()
	defer l.locker.Unlock()
	l.lazyInit()
	delete(l.predefs, key)
	l.clearPredefsCache()
}

func (l *logger) clearPredefsCache() {
	l.predefsInh = nil
	l.predefsCur = nil
	l.predefsFin = nil
}

func (l *logger) Debug(message string, kvfields ...interface{}) {
	l.doLog(LevelDebug, message, kvfields...)
}

func (l *logger) Info(message string, kvfields ...interface{}) {
	l.doLog(LevelInfo, message, kvfields...)
}

func (l *logger) Warn(message string, kvfields ...interface{}) {
	l.doLog(LevelWarn, message, kvfields...)
}

func (l *logger) Error(message string, kvfields ...interface{}) {
	l.doLog(LevelError, message, kvfields...)
}

func (l *logger) Panic(message string, kvfields ...interface{}) {
	l.doLog(LevelPanic, message, kvfields...)
	panic(message)
}

func (l *logger) Fatal(message string, kvfields ...interface{}) {
	l.doLog(LevelFatal, message, kvfields...)
	os.Exit(1)
}

func (l *logger) doLog(level int, message string, kvfields ...interface{}) {
	if level < l.Level() {
		return
	}
	handler := l.Handler()
	if handler == nil {
		return
	}
	predefs := l.Predefs()

	fields := make(Fields)
	for k, v := range predefs {
		fields[k] = v
	}
	if (len(kvfields) % 2) != 0 {
		panic("golog : invalid kvfields")
	}
	for i := 0; i < len(kvfields); i += 2 {
		k, ok := kvfields[i].(string)
		if !ok {
			panic("golog : invalid kvfields")
		}
		v := kvfields[i+1]
		fields[k] = specialV(v)
	}

	log := &Log{
		Level:   level,
		Time:    time.Now(),
		Message: message,
		Fields:  fields,
	}
	handler.ProcessLog(log)
}

func specialV(v interface{}) interface{} {
	switch s := v.(type) {
	case error:
		return s.Error()
	case fmt.Stringer:
		return s.String()
	default:
		return v
	}
}
